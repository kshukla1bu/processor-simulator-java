/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package apexsimulator;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.LineNumberReader;

 

class Code_Line{
    int line_no;
    int address;
    String Inst_String;
}

class Code_Memory{
    Code_Line c1[];
    
    Code_Memory(Code_Line c1[])
    {
        this.c1 = c1;
    }
    
}

class Data_Memory{
    int base_address;
    int data_mem_address[];
    Data_Memory(int data_mem_address[])
    {
        this.data_mem_address = data_mem_address;
    }
    //data_array
}

class Register{
    int value;
    boolean status;
}

class Register_File{
    Register R[];
    
    Register_File(Register R[])
    {
        this.R = R;
    }
}

class Instruction_info{
    int PC;
    String inst_string;
    int val_src_reg1;
    int addr_src_reg1;
    int val_src_reg2;
    int addr_src_reg2;
    int val_dest_reg;
    int addr_dest_reg;
    int tar_mem_addr;
    int tar_mem_data;
    String opcode;
    int literal;
}

class stage{
    Instruction_info ip_instruction;
    Instruction_info op_instruction;
    boolean stalled;
}

class Flags{
    boolean zero, carry, negative;
}

class Stats{
    int cycle;
}


public class NewMain 
    {
        int i = 0;
        String temp;
        stage stg[];
        stage stgM1;
        stage stgM2;
        int j=0;
        int baseAddress = 4000;
        int lnNumber = 1;
        public Code_Memory cme;
        public Register_File RFile;
        public Data_Memory dme;
        public Flags flag;
        public Stats stat;
        int bubbles = 0; 
        boolean EndOfCycle = false;
        boolean temp_status;
        int arithmetic_inst_cnt = 0;
        int temp_index;
        boolean branch;
        boolean OneCycleWait;
        boolean halt;
        boolean exeWait;
        
        
        
        /**
        * @param args the command line arguments
        */
        
        ApexSimulator()
        {
            stg = new stage[5];
            stgM1 = new stage();
            stgM2 = new stage();
            stg[0] = new stage();
            stg[1] = new stage();
            stg[2] = new stage();
            stg[2] = new stage();
            stg[3] = new stage();
            stg[4] = new stage();
        }
        
        public static void main(String[] args) 
        {
            ApexSimulator ApSim = new ApexSimulator();
            ApSim.initialize();
            ApSim.simulate();
        
            // TODO code application logic here
        }
    int n  = 0;
    void fetch()
    {
        Instruction_info instructionInfo = new Instruction_info();
        if((branch && !OneCycleWait)) // || (branch && OneCycleWait))
        {
            if  ( n < lnNumber-1)
            {
                instructionInfo.inst_string = cme.c1[n].Inst_String;
                instructionInfo.PC = cme.c1[n].address;
                System.out.println("FETCH Stage :"+cme.c1[n].Inst_String);
                stg[0].op_instruction = instructionInfo;
                if(!stg[0].stalled && !stg[1].stalled)
                {
                    stg[0].op_instruction = instructionInfo;
                    stg[1].ip_instruction = stg[0].op_instruction;
                    stg[0].op_instruction = null; 
                    n = n + 1;
                }
            }
            branch = false;
          //  halt = false;
            return;
        }
        
        if( n < lnNumber-1)
        {
            instructionInfo.inst_string = cme.c1[n].Inst_String;
            instructionInfo.PC = cme.c1[n].address;
            System.out.println("FETCH Stage :"+cme.c1[n].Inst_String);
            stg[0].op_instruction = instructionInfo;
            if(!stg[0].stalled && !stg[1].stalled)
            {
                stg[0].op_instruction = instructionInfo;
                stg[1].ip_instruction = stg[0].op_instruction;
                stg[0].op_instruction = null; 
                n = n + 1;
            }
        }
        else
        {
            System.out.println("No Instruction in FETCH");
            return;
        }
            
        if(branch && OneCycleWait)
        {
            n = temp_index;
            for(int i = 0;i<RFile.R.length;i++)
            RFile.R[i].status = false;
            OneCycleWait = false;
            stg[1].ip_instruction = null;
            stg[2].ip_instruction = null;
        }
        
       /*  if(!halt)
        {
            stg[1].ip_instruction = null;
            stg[2].ip_instruction = null;
            return;
        } */
        
        
    }
    
    void decode()
    {
        String temp;
        Instruction_info instructionInfo = stg[1].ip_instruction ;
        if(instructionInfo == null)
        {
            System.out.println("No Instruction in DECODE");
            return;
        }
        temp_status = false;
        String Splitter[] = instructionInfo.inst_string.split(",");
        instructionInfo.opcode = Splitter[0];
        
        for(int i=0; i<Splitter.length; i++)
        {
            if(i==0)
                continue;
            
            if(Splitter[i].contains("R") || Splitter[i].contains("#"))
                Splitter[i] = Splitter[i].substring(1);
        
            switch(instructionInfo.opcode){
                case("MOVC"):
                    if(i==1)
                    {
                        int regNo = Integer.parseInt(Splitter[i]);
                        instructionInfo.addr_dest_reg = regNo;
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.literal = Integer.parseInt(Splitter[i]);
                    }
                    break;
                case("ADD"):
                    if(i==1)
                    {
                        int regNo = Integer.parseInt(Splitter[i]);
                        instructionInfo.addr_dest_reg = regNo;
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.addr_src_reg2 = Integer.parseInt(Splitter[i]);
                    }
                    break;
                case("SUB"):
                    if(i==1)
                    {
                        int regNo = Integer.parseInt(Splitter[i]);
                        instructionInfo.addr_dest_reg = regNo;
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.addr_src_reg2 = Integer.parseInt(Splitter[i]);
                    }
                    break;
                case("LOAD"):
                    if(i==1)
                    {
                        instructionInfo.addr_dest_reg = Integer.parseInt(Splitter[i]); 
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.literal = Integer.parseInt(Splitter[i]);
                    }   
                    break;
                case("STORE"):
                    if(i==1)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg2 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.literal = Integer.parseInt(Splitter[i]);
                    }
                    break;
                case("BZ"):
                    if(i==1)
                        instructionInfo.literal = Integer.parseInt(Splitter[i]);
                    break;
                case("BNZ"):
                    if(i==1)
                        instructionInfo.literal = Integer.parseInt(Splitter[i]);
                    break;
                case("JUMP"):
                    if(i==1)
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    if(i==2)
                        instructionInfo.literal = Integer.parseInt(Splitter[i]);
                    break;
                case("HALT"):
                    OneCycleWait = true;
                    halt = true;
                    break;
                case("AND"):
                    if(i==1)
                    {
                        int regNo = Integer.parseInt(Splitter[i]);
                        instructionInfo.addr_dest_reg = regNo;
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.addr_src_reg2 = Integer.parseInt(Splitter[i]);
                    }
                    break;
                case("OR"):
                    if(i==1)
                    {
                        int regNo = Integer.parseInt(Splitter[i]);
                        instructionInfo.addr_dest_reg = regNo;
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.addr_src_reg2 = Integer.parseInt(Splitter[i]);
                    }
                    break;
                case("XOR"):
                    if(i==1)
                    {
                        int regNo = Integer.parseInt(Splitter[i]);
                        instructionInfo.addr_dest_reg = regNo;
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.addr_src_reg2 = Integer.parseInt(Splitter[i]);
                    }
                    break;
                case("MUL"):
                    if(i==1)
                    {
                        int regNo = Integer.parseInt(Splitter[i]);
                        instructionInfo.addr_dest_reg = regNo;
                        temp_status = true;
                    }
                    if(i==2)
                    {
                        instructionInfo.addr_src_reg1 = Integer.parseInt(Splitter[i]);
                    }
                    if(i==3)
                    {
                        instructionInfo.addr_src_reg2 = Integer.parseInt(Splitter[i]);
                    }
                }
            }
        
        switch(instructionInfo.opcode){
            case("ADD"):
            case("SUB"):
            case("MUL"):
            case("AND"):    
            case("OR"):
            case("XOR"):
            case("STORE"):
                if(RFile.R[instructionInfo.addr_src_reg1].status || RFile.R[instructionInfo.addr_src_reg2].status)
                    {
                        stg[1].stalled = true;
                        stg[0].stalled = true;
                    }
                    break;
            case("LOAD"):
            case("JUMP"):
                if(RFile.R[instructionInfo.addr_src_reg1].status)
                {
                        stg[1].stalled = true;
                        stg[0].stalled = true;
                }
                break;
            case("BZ"):
            case("BNZ"):
                if(arithmetic_inst_cnt != 0)
                {
                    stg[1].stalled = true;
                    stg[0].stalled = true;
                }
                break;
        }
      
        System.out.println("DECODE Stage :"+instructionInfo.inst_string);
        if(stg[1].stalled && stg[0].stalled)
      {
          System.out.println("stage Stalled");
          System.out.println("Arithmatic instrn count: " + arithmetic_inst_cnt);
      }
        if(arithmetic_inst_cnt == 0 && (instructionInfo.opcode.equalsIgnoreCase("BZ")|| instructionInfo.opcode.equalsIgnoreCase("BNZ")))
        {
            stg[1].op_instruction = instructionInfo;
            stg[2].ip_instruction = stg[1].op_instruction;
            stg[1].ip_instruction = null;
            return;
        }
        if(!stg[0].stalled && !stg[1].stalled)
        {
            RFile.R[instructionInfo.addr_dest_reg].status = temp_status;
            System.out.println("\t\tRegister status of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].status);
            if(instructionInfo.opcode.equals("ADD")||
               instructionInfo.opcode.equals("SUB")||
               instructionInfo.opcode.equals("MUL")||
               instructionInfo.opcode.equals("AND")||
               instructionInfo.opcode.equals("OR")||
               instructionInfo.opcode.equals("XOR"))
                arithmetic_inst_cnt++;
            if(instructionInfo.opcode.equals("MUL"))
            {
                stg[1].op_instruction = instructionInfo;
                stgM1.ip_instruction = stg[1].op_instruction;
                stg[1].ip_instruction = null;
            }
            else
            {    
                stg[1].op_instruction = instructionInfo;
                stg[2].ip_instruction = stg[1].op_instruction;
                stg[1].ip_instruction = null;
            }
            
        }
        else
            bubbles++;
        
    }
    
    void multiply1()
    {
        int temp_val = 0;
        Instruction_info instructionInfo = stgM1.ip_instruction;
        if(instructionInfo == null)
        {
            System.out.println("\t\t\tNo Instruction in MULTIPLY 1");
            return;
        }
        instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
        instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
        temp_val = instructionInfo.val_src_reg1 * instructionInfo.val_src_reg2;
        instructionInfo.val_dest_reg = temp_val;
        System.out.println("\t\t\tMULTIPLY 1 Stage :"+instructionInfo.inst_string);
        stgM1.op_instruction = instructionInfo;
        stgM2.ip_instruction = stgM1.op_instruction;
        stgM1.ip_instruction = null;
    }
    
    void multiply2()
    {
        Instruction_info instructionInfo = stgM2.ip_instruction;
        if(instructionInfo == null)
        {
            System.out.println("\t\t\tNo Instruction in MULTIPLY 2");
            return;
        }
        System.out.println("\t\t\tMULTIPLY 2 Stage :"+instructionInfo.inst_string);
        exeWait = true;
        stgM2.op_instruction = instructionInfo;
        stg[3].ip_instruction = stgM2.op_instruction;
        stgM2.ip_instruction = null;
    }
    
    void execute()
    {
        int temp_val = 0;
        
        Instruction_info instructionInfo = stg[2].ip_instruction;
        if(instructionInfo == null)
        {
            System.out.println("No Instruction in EXECUTE");
            return;
        }    
        switch(instructionInfo.opcode){
            case("MOVC"):
                temp_val = temp_val + instructionInfo.literal;
                break;
            case("ADD"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
                temp_val = instructionInfo.val_src_reg1 + instructionInfo.val_src_reg2;
                break;
            case("SUB"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
                temp_val = instructionInfo.val_src_reg1 - instructionInfo.val_src_reg2;
                break;
            case("LOAD"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                temp_val = instructionInfo.val_src_reg1 + instructionInfo.literal;
                break;
            case("STORE"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
                temp_val = instructionInfo.val_src_reg2 + instructionInfo.literal;
                break;
            case("BZ"):
                if(flag.zero)
                {
                    temp_val = instructionInfo.PC + (instructionInfo.literal);
                    temp_index = (temp_val-4000)/4;
                    branch = true;
                    OneCycleWait = true;
                }
                break;
            case("BNZ"):
                if(!flag.zero)
                {
                    temp_val = instructionInfo.PC + (instructionInfo.literal);
                    temp_index = (temp_val-4000)/4;
                    branch = true;
                    OneCycleWait = true;
                }
                break;
            case("JUMP"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                temp_val = instructionInfo.val_src_reg1 + (instructionInfo.literal);
                temp_index = (temp_val-4000)/4;
                branch = true;
                OneCycleWait = true;
                break;
            case("HALT"):
                
                
                break;
            case("AND"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
                temp_val =  instructionInfo.val_src_reg1 & instructionInfo.val_src_reg2;
                break;
            case("OR"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
                temp_val =  instructionInfo.val_src_reg1 | instructionInfo.val_src_reg2;
                break;
            case("XOR"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
                temp_val =  instructionInfo.val_src_reg1 ^ instructionInfo.val_src_reg2;
                break;
            case("MUL"):
                instructionInfo.val_src_reg1 = RFile.R[instructionInfo.addr_src_reg1].value;
                instructionInfo.val_src_reg2 = RFile.R[instructionInfo.addr_src_reg2].value;
                temp_val =  instructionInfo.val_src_reg1 ^ instructionInfo.val_src_reg2;
                break;
        }
        instructionInfo.val_dest_reg = temp_val;
        System.out.println("EXECUTE Stage :"+instructionInfo.inst_string);
        stg[2].op_instruction = instructionInfo;
        stg[3].ip_instruction = stg[2].op_instruction;
        stg[2].ip_instruction = null;
    }
    
    void mem()
    {
        Instruction_info instructionInfo = stg[3].ip_instruction;
        if(instructionInfo == null)
        {
            System.out.println("No Instruction in MEMORY");
            return;
        }
         switch(instructionInfo.opcode){
            case("MOVC"):
                break;
            case("ADD"):
                break;
            case("SUB"):
                break;
            case("LOAD"):
                instructionInfo.tar_mem_data = dme.data_mem_address[instructionInfo.val_dest_reg];
                break;
            case("STORE"):
                dme.data_mem_address[instructionInfo.val_dest_reg] = instructionInfo.val_src_reg1;
                break;
            case("BZ"):
                break;
            case("BNZ"):
                break;
            case("JUMP"):
                break;
            case("HALT"):
                break;
            case("AND"):
                break;
            case("OR"):
                break;
            case("XOR"):    
                break;
            case("MUL"):
                exeWait = false;
                break;
        }
        System.out.println("MEMORY Stage :"+instructionInfo.inst_string); 
        stg[3].op_instruction = instructionInfo;
        stg[4].ip_instruction = stg[3].op_instruction;
        stg[3].ip_instruction = null;
    }
    
    void writeback()
    {
        Instruction_info instructionInfo = stg[4].ip_instruction;
        if(instructionInfo == null)
        {
            System.out.println("No Instruction in WRITEBACK");
            return;
        }
        //if(stg[4].ip_instruction.PC == PCValueOfLastInstruction)
            //endOfCycle = true;
      //  System.out.println("Inside WRITEBACK Stage");
         switch(instructionInfo.opcode){
            case("MOVC"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.val_dest_reg;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister status of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].status);
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }
                break;
            case("ADD"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.val_dest_reg;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(RFile.R[instructionInfo.addr_dest_reg].value == 0)
                {
                    flag.zero = true;
                }
                else
                    flag.zero = false;
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }
                break;
            case("SUB"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.val_dest_reg;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(RFile.R[instructionInfo.addr_dest_reg].value == 0)
                {
                    flag.zero = true;
                }
                else
                    flag.zero = false;
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }
                break;
            case("LOAD"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.tar_mem_data;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }
                break;    
            case("STORE"):
                break;    
            case("BZ"):
                break;    
            case("BNZ"):
                break;    
            case("JUMP"):
                break;    
            case("HALT"):
                break;    
            case("AND"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.val_dest_reg;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(RFile.R[instructionInfo.addr_dest_reg].value == 0)
                {
                    flag.zero = true;
                }
                else
                    flag.zero = false;
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }
                break;    
            case("OR"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.val_dest_reg;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(RFile.R[instructionInfo.addr_dest_reg].value == 0)
                {
                    flag.zero = true;
                }
                else
                    flag.zero = false;
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }
                break;
            case("XOR"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.val_dest_reg;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(RFile.R[instructionInfo.addr_dest_reg].value == 0)
                {
                    flag.zero = true;
                }
                else
                    flag.zero = false;
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }
                break;
            case("MUL"):
                RFile.R[instructionInfo.addr_dest_reg].value = instructionInfo.val_dest_reg;
                RFile.R[instructionInfo.addr_dest_reg].status = false;
                System.out.println("\t\tRegister value of R"+instructionInfo.addr_dest_reg+" is : "+RFile.R[instructionInfo.addr_dest_reg].value);
                if(RFile.R[instructionInfo.addr_dest_reg].value == 0)
                {
                    flag.zero = true;
                }
                else
                    flag.zero = false;
                if(!RFile.R[instructionInfo.addr_src_reg1].status && !RFile.R[instructionInfo.addr_src_reg2].status)
                {
                    stg[1].stalled = false;
                    stg[0].stalled = false;
                }    
                break;
        }
         stg[0].stalled = false;
         stg[1].stalled = false;
         System.out.println("WRITEBACK Stage :"+instructionInfo.inst_string);
       //  System.out.println("Status of dest register R[" + instructionInfo.addr_dest_reg + "] changed to false.");
         if(instructionInfo.opcode.equals("ADD")||
               instructionInfo.opcode.equals("SUB")||
               instructionInfo.opcode.equals("MUL")||
               instructionInfo.opcode.equals("AND")||
               instructionInfo.opcode.equals("OR")||
               instructionInfo.opcode.equals("XOR"))
                arithmetic_inst_cnt--;
        
        stg[4].ip_instruction = null;
    }
    
    void simulate()
    {
        int m = 0;
        stat = new Stats();
        stat.cycle = 0;
            while(true)
            {
                writeback();
                mem();
                multiply2();
                multiply1();
                execute();
                decode();
                fetch();
                stat.cycle++;
                m++;
                System.out.println("End of Cycle: "+m);
                System.out.println();
                if(m==8)
                    System.out.println();
                
                if(m == 40)  //endOfCYcle
                  break;
            }
            System.out.println("No of bubbles :"+bubbles);
       
    }
        
    void initialize()
    {
        try
        {
            int j=0;
            int baseAddress = 4000;
            
            Code_Line cl[] = new Code_Line[100];
            Register register[] = new Register[16];
            // Open the file
            FileInputStream fstream = new FileInputStream("test2.txt");
            // Get the object of DataInputStream
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String strLine;
            while ((strLine = br.readLine()) != null)
            {
                //System.out.println(strLine);
                Code_Line line = new Code_Line();
                line.Inst_String = strLine;
            //    line.Inst_String = strLine;
                line.address = baseAddress;
                line.line_no = lnNumber;
                cl[lnNumber-1] = line;
                baseAddress = baseAddress + 4;
                System.out.println(lnNumber+":"+baseAddress+":"+strLine);
                String[] splitted = strLine.split(",");
                lnNumber++;
                j++;
            }
            System.out.println(lnNumber-1+" lines of file");
            System.out.println(baseAddress+" lines of file");
            cme = new Code_Memory(cl);
            int mem_add[] = new int[20000];
            dme = new Data_Memory(mem_add);
            flag = new Flags();
            Flags flg = new Flags();
            flg.carry=false;
            flg.negative=false;
            flg.zero=false;
            for(int i=0; i<register.length ; i++)
            {
                register[i] = new Register();
                register[i].status = false;
                register[i].value = 0;
                
            }
            RFile = new Register_File(register);
            System.out.println(cl[1].address);
            for(int i=0; i<RFile.R.length ; i++)
            {
                System.out.println("R[" + i + "] = " + RFile.R[i].value + ", Status= " + RFile.R[i].status);
            }
            i=0;
            while(cme.c1[i] != null)
            {
                System.out.println("Code Memory: " + cme.c1[i].Inst_String);
                i++;
            }
            in.close();
        }
        catch (Exception e)
        {//Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
    }
    
}


 

    

